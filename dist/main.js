/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.html":
/*!************************!*\
  !*** ./src/index.html ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_html_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/html-loader/dist/runtime/getUrl.js */ \"./node_modules/html-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_html_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_html_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___HTML_LOADER_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./favicon.ico */ \"./src/favicon.ico\"), __webpack_require__.b);\nvar ___HTML_LOADER_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ./css/main.css */ \"./src/css/main.css\"), __webpack_require__.b);\nvar ___HTML_LOADER_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! ./css/app.css */ \"./src/css/app.css\"), __webpack_require__.b);\nvar ___HTML_LOADER_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! ./asset/img/background.png */ \"./src/asset/img/background.png\"), __webpack_require__.b);\n// Module\nvar ___HTML_LOADER_REPLACEMENT_0___ = _node_modules_html_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_0___default()(___HTML_LOADER_IMPORT_0___);\nvar ___HTML_LOADER_REPLACEMENT_1___ = _node_modules_html_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_0___default()(___HTML_LOADER_IMPORT_1___);\nvar ___HTML_LOADER_REPLACEMENT_2___ = _node_modules_html_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_0___default()(___HTML_LOADER_IMPORT_2___);\nvar ___HTML_LOADER_REPLACEMENT_3___ = _node_modules_html_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_0___default()(___HTML_LOADER_IMPORT_3___);\nvar code = \"<!DOCTYPE html>\\r\\n<head>\\r\\n    <meta charset=\\\"UTF-8\\\">\\r\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\\r\\n    <meta name=\\\"description\\\" content=\\\"description of your project\\\">\\r\\n    <meta name=\\\"keywords\\\" content=\\\"key1, key2, ...\\\">\\r\\n    <meta name=\\\"author\\\" content=\\\"your name\\\">\\r\\n    <title>Project Title</title>\\r\\n    <link rel=\\\"icon shortcut\\\" href=\\\"\" + ___HTML_LOADER_REPLACEMENT_0___ + \"\\\">\\r\\n    <link rel=\\\"stylesheet\\\" href=\\\"\" + ___HTML_LOADER_REPLACEMENT_1___ + \"\\\">\\r\\n    <link rel=\\\"stylesheet\\\" href=\\\"\" + ___HTML_LOADER_REPLACEMENT_2___ + \"\\\" about=\\\"app\\\">\\r\\n</head>\\r\\n<header></header>\\r\\n<body>\\r\\n<!-- -the main page that will be displayed in the app -->\\r\\n\\r\\n<div class=\\\"header\\\">\\r\\n<button> Buy Now  </button>\\r\\n</div>\\r\\n<div>\\r\\n    <img src=\\\"\" + ___HTML_LOADER_REPLACEMENT_3___ + \"\\\" alt=\\\"\\\">\\r\\n</div>\\r\\n<div id=\\\"app\\\" class=\\\"shadow\\\">\\r\\n    <p>{{msg}}</p>\\r\\n</div>\\r\\n</body>\\r\\n\";\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (code);\n\n//# sourceURL=webpack://hello-npm/./src/index.html?");

/***/ }),

/***/ "./node_modules/html-loader/dist/runtime/getUrl.js":
/*!*********************************************************!*\
  !*** ./node_modules/html-loader/dist/runtime/getUrl.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\r\n\r\nmodule.exports = function (url, options) {\r\n  if (!options) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    options = {};\r\n  }\r\n\r\n  if (!url) {\r\n    return url;\r\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\r\n\r\n\r\n  url = String(url.__esModule ? url.default : url);\r\n\r\n  if (options.hash) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    url += options.hash;\r\n  }\r\n\r\n  if (options.maybeNeedQuotes && /[\\t\\n\\f\\r \"'=<>`]/.test(url)) {\r\n    return \"\\\"\".concat(url, \"\\\"\");\r\n  }\r\n\r\n  return url;\r\n};\n\n//# sourceURL=webpack://hello-npm/./node_modules/html-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/seule/index.js":
/*!*************************************!*\
  !*** ./node_modules/seule/index.js ***!
  \*************************************/
/***/ ((module) => {

eval("\r\n\r\nclass Seule {\r\n    constructor(app) {\r\n        this.child = false;\r\n        this.data = app.data || {};\r\n        this.RootElement = selectElement(app.el);\r\n\r\n        let old = \"\",\r\n            firstEl = selectElement(app.el),\r\n            init = () => this.Init(),\r\n            Shadow = () => {\r\n                let el = firstEl.el,\r\n                    seule = {},\r\n                    e = firstEl.e,\r\n                    child = \"\";\r\n\r\n                class Root extends HTMLElement {\r\n                    constructor() {\r\n                        super();\r\n                        const shadow = this.attachShadow({\r\n                            mode: \"closed\"\r\n                        });\r\n\r\n                        selectStyle(app.style, shadow)\r\n\r\n                        let cl = el.cloneNode(true);\r\n                        el.innerHTML = \"\";\r\n                        shadow.appendChild(cl);\r\n                        child = shadow.children[shadow.children.length - 1];\r\n\r\n                        shadow.children[shadow.children.length - 1].removeAttribute(\"id\");\r\n                    }\r\n                }\r\n\r\n                customElements.define(\"seule-\" + e, Root);\r\n                seule = document.createElement(\"seule-\" + e);\r\n\r\n                el.appendChild(seule);\r\n                this.child = child;\r\n                old = child.innerHTML;\r\n            },\r\n            Find = (selector, dom) => {\r\n                let parent = this.child;\r\n\r\n                class el\r\n                {\r\n                    constructor(select) {\r\n                        if(!select && dom) return new el(window);\r\n                        if(!select) return new el(parent);\r\n\r\n                        try {\r\n                            dom ? this.el = firstEl.context.querySelectorAll(select) :\r\n                                this.el = parent.querySelectorAll(select);\r\n                        } catch (e) {\r\n                            select.length ? this.el = select :\r\n                                this.el = [select];\r\n                        }\r\n                    }\r\n\r\n                    $() {\r\n                        return new el(parent);\r\n                    }\r\n\r\n                    Select(selector) {\r\n                        let elements = [];\r\n                        this.Each(function (){\r\n                            for(const e of this.querySelectorAll(selector))\r\n                                elements.push(e)\r\n                        })\r\n                        return new el(elements);\r\n                    }\r\n\r\n                    Element(index) {\r\n                        return new el(this.el[index]);\r\n                    }\r\n\r\n                    Dom(index) {\r\n                        if (index || index === 0) return this.el[index];\r\n                        return this.el;\r\n                    }\r\n\r\n                    Parent(element) {\r\n                        if(!element) return new el(this.el[0].parentElement);\r\n\r\n                        const es = new el(element.el ? element.Dom(0): parent.querySelector(element));\r\n\r\n                        es.Append(this)\r\n                    }\r\n\r\n                    Child(){\r\n                        let obj = {};\r\n                        obj.first = ()=> new el(this.el[0].children[0]);\r\n                        obj.last = ()=> new el(this.el[0].children[this.el[0].children.length-1]);\r\n                        obj.number = index=> new el(this.el[0].children[index]);\r\n                        obj.all = ()=> new el(this.el[0].children);\r\n                        return obj;\r\n                    }\r\n\r\n                    Move() {\r\n                        let op = {};\r\n\r\n                        op.after = (element) => {\r\n                            const es = new el(element.el ? element.Dom(): element);\r\n                            es.Parent().Dom(0).insertBefore(this.el[0], es.Dom(0).nextSibling);\r\n                            return this;\r\n                        };\r\n\r\n                        op.before = (element) => {\r\n                            const es = new el(element.el ? element.Dom(): element);\r\n                            es.Parent().Dom(0).insertBefore(this.el[0], es.Dom(0));\r\n                            return this;\r\n                        };\r\n\r\n                        return op;\r\n                    }\r\n\r\n                    Append(element){\r\n                        const es = new el(element.el ? element.Dom(): element);\r\n\r\n                        return this.Each(function () {\r\n                            for(const e of es.Dom())\r\n                                this.appendChild(e);\r\n                        })\r\n                    }\r\n\r\n                    Remove(){\r\n                        return this.Each(function () {\r\n                            this.parentNode.removeChild(this);\r\n                        })\r\n                    }\r\n\r\n                    Duplicate(){\r\n                        let newEls = [],\r\n                            element,\r\n                            clone,\r\n                            event;\r\n                        this.Each(function () {\r\n                            element = new el(this);\r\n                            event = element.GetEvents();\r\n                            clone = this.cloneNode(true);\r\n                            for (const ev of event){\r\n                                clone.addEventListener(ev.type, ev.listener)\r\n                            }\r\n                            newEls.push(clone)\r\n                        });\r\n\r\n                        return  new el(newEls)\r\n                    }\r\n\r\n                    Replace(element){\r\n                        const es = new el(element.el ? element.Dom(): element);\r\n\r\n                        for (const e of es.Dom()){\r\n                            let el = this.el[0].cloneNode(true);\r\n                            e.parentNode.replaceChild(el, e);\r\n                        }\r\n\r\n                        return this;\r\n                    }\r\n\r\n                    Create(tagName){\r\n                        return new el(document.createElement(tagName));\r\n                    }\r\n\r\n                    Each(callback) {\r\n                        for (const element of this.el) callback.call(element, new el(element));\r\n                        return this;\r\n                    }\r\n\r\n                    Load(handler, timeOut = 0) {\r\n                        return this.Each(function (e) {\r\n                            setTimeout(() => {\r\n                                handler(new el(this));\r\n                            }, timeOut);\r\n                        });\r\n                    }\r\n\r\n                    Loop(handler, timeOut = 1000) {\r\n                        return this.Each(function (e) {\r\n                            let loop = {\r\n                                    stop: (handler) => stop(handler),\r\n                                    counter: 0,\r\n                                    el: new el(this)\r\n                                },\r\n                                repeat = setInterval(() => {\r\n                                    handler(loop);\r\n                                    loop.counter++;\r\n                                }, timeOut);\r\n\r\n                            function stop(handler) {\r\n                                clearInterval(repeat);\r\n                                handler && handler(loop.el);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    On(event, handler, initial) {\r\n                        if (event === \"hold\") this.Hold(handler);\r\n                        else\r\n                            return this.Each(function () {\r\n                                handler && this.addEventListener(\r\n                                    event,\r\n                                    () => {\r\n                                        handler(new el(this), this);\r\n                                        initial && init();\r\n                                    },\r\n                                    false\r\n                                );\r\n                            });\r\n                    }\r\n\r\n                    Click(handler, initial) {\r\n                        handler\r\n                            ? this.On(\"click\", (el) => handler(el), initial)\r\n                            : this.Fire(\"click\");\r\n                        return this;\r\n                    }\r\n\r\n                    Hold(handler, time = 1500) {\r\n                        return this.Each(function () {\r\n                            let mouseIsDown = false,\r\n                                isTouch =\r\n                                    \"ontouchstart\" in window ||\r\n                                    navigator.MaxTouchPoints > 0 ||\r\n                                    navigator.msMaxTouchPoints > 0,\r\n                                mouseDown = isTouch ? \"touchstart\" : \"mousedown\",\r\n                                mouseUp = isTouch ? \"touchend\" : \"mouseup\";\r\n                            this.addEventListener(mouseDown, (e) => {\r\n                                mouseIsDown = true;\r\n                                setTimeout(function () {\r\n                                    mouseIsDown && handler(new el(e), e);\r\n                                }, time);\r\n                            });\r\n                            this.addEventListener(mouseUp, () => (mouseIsDown = false));\r\n                        });\r\n                    }\r\n\r\n                    Focus(handler, initial) {\r\n                        handler\r\n                            ? this.On(\"focus\", (el) => handler(el), initial)\r\n                            : this.Fire(\"focus\");\r\n\r\n                        return this;\r\n                    }\r\n\r\n                    Blur(handler, initial) {\r\n                        handler\r\n                            ? this.On(\"blur\", (el) => handler(el), initial)\r\n                            : this.Fire(\"blur\");\r\n                        return this;\r\n                    }\r\n\r\n                    Swipe(on, handler) {\r\n                        let elem = this.el,\r\n                            xDown,\r\n                            yDown;\r\n\r\n                        for (let e of elem) {\r\n                            e.addEventListener(\"touchstart\", handleTouchStart, false);\r\n                            e.addEventListener(\"touchmove\", handleTouchMove, false);\r\n                        }\r\n\r\n                        function handleTouchStart(evt) {\r\n                            xDown = evt.touches[0].clientX;\r\n                            yDown = evt.touches[0].clientY;\r\n                        }\r\n\r\n                        function handleTouchMove(evt) {\r\n                            if (!xDown || !yDown) return;\r\n                            let xUp = evt.touches[0].clientX,\r\n                                yUp = evt.touches[0].clientY,\r\n                                xDiff = xDown - xUp,\r\n                                yDiff = yDown - yUp;\r\n\r\n                            if (Math.abs(xDiff) > Math.abs(yDiff)) {\r\n                                if (xDiff > 10 && on === \"left\") handler(new el(this));\r\n                                if (xDiff < -10 && on === \"right\") handler(new el(this));\r\n                            }\r\n                            else {\r\n                                if (yDiff > 10 && on === \"top\") handler(new el(this));\r\n                                if (yDiff < -10 && on === \"bottom\") handler(new el(this));\r\n                            }\r\n\r\n                            xDown = null;\r\n                            yDown = null;\r\n                        }\r\n\r\n                        return this;\r\n                    }\r\n\r\n                    HotKey(query, handler, prevent) {\r\n                        let key = \"\",\r\n                            start,\r\n                            mapObj = {\r\n                                Arrow: \"\",\r\n                                Control: \"ctrl\"\r\n                            },\r\n                            querys = query.replace(/\\s/g, \"\");\r\n                        return this.Each(function () {\r\n                            this.addEventListener(\r\n                                \"keydown\",\r\n                                function (event) {\r\n                                    prevent && event.preventDefault();\r\n\r\n\r\n\r\n                                    key += event.key;\r\n\r\n                                    key = key.replace(/Arrow|Control/gi, function (matched) {\r\n                                        return mapObj[matched];\r\n                                    });\r\n\r\n                                    key = key.replace(/ /g,\"space\");\r\n\r\n\r\n\r\n                                    start = key.toLowerCase().indexOf(querys.toLowerCase());\r\n\r\n                                    if (start > -1) {\r\n                                        handler && handler(new el(this));\r\n                                        this.focus();\r\n                                        key = \"\";\r\n                                    }\r\n                                },\r\n                                true\r\n                            );\r\n                        });\r\n                    }\r\n\r\n                    Fire(event){\r\n                        return this.Each(function () {\r\n                            event && this[event]()\r\n                        });\r\n                    }\r\n\r\n                    Copy(target, events) {\r\n                        let tar,\r\n                            ons = events.split(\":\");\r\n\r\n                        (typeof target === \"string\")\r\n                            ? tar = parent.querySelector(target)\r\n                            : tar = target;\r\n\r\n                        for (let on of ons) {\r\n                            this.On(on.trimStart().trimEnd(), function () {\r\n                                let eventFired = new MouseEvent(on.trimStart().trimEnd(), {\r\n                                    view: window,\r\n                                    bubbles: true,\r\n                                    cancelable: true\r\n                                });\r\n                                tar.dispatchEvent(eventFired);\r\n                            });\r\n                        }\r\n\r\n                        return this;\r\n                    }\r\n\r\n                    Toggle(event, methods, initial) {\r\n                        let check = true;\r\n                        this.On(event, function (el) {\r\n                            if (check) {\r\n                                methods.handler && methods.handler(el);\r\n                                check = false;\r\n                                return;\r\n                            }\r\n                            methods.callback && methods.callback(el);\r\n                            check = true;\r\n                        }, initial);\r\n                        return this;\r\n                    }\r\n\r\n                    Not(selector, options ){\r\n                        let e = new el(this.el),\r\n                            exceptions = e.Select(`:not(${selector})`);\r\n\r\n                        if(options){\r\n                            return this.Each(function (){\r\n                                this.addEventListener(options.event, (evt) => {\r\n                                    const flyoutElement = e.Select(selector).Dom()\r\n                                    let targetElement = evt.target; // clicked element\r\n\r\n\r\n                                    do {\r\n                                        if (flyoutElement.includes(targetElement)) {\r\n                                            // Do nothing, just return.\r\n                                            options.callback && options.callback()\r\n                                            return;\r\n                                        }\r\n                                        // Go up the DOM.\r\n                                        targetElement = targetElement.parentNode;\r\n                                    } while (targetElement);\r\n\r\n                                    // Do something useful here.\r\n                                    options.handler && options.handler()\r\n                                });\r\n                            })\r\n\r\n\r\n                        }\r\n\r\n                        return exceptions\r\n                    }\r\n\r\n                    GetEvents(event){\r\n                        let events = [];\r\n                        for (const ev of Object.values(this.el[0].getEventListeners(event)))\r\n                            event ? events.push(ev) : events.push(ev[0]);\r\n                        return events\r\n                    }\r\n\r\n                    Visible() {\r\n                        let options = {};\r\n\r\n                        options.showing = () => {\r\n                            for (let el of this.el) el.style.visibility = \"visible\";\r\n\r\n                            return this;\r\n                        };\r\n\r\n                        options.hidden = () => {\r\n                            for (let el of this.el) el.style.visibility = \"hidden\";\r\n\r\n                            return this;\r\n                        };\r\n\r\n                        options.status = () => this.el[0].style.visibility !== \"hidden\";\r\n\r\n                        return options;\r\n                    }\r\n\r\n                    Show() {\r\n                        return this.Each(function () {\r\n                            let front = this.getAttribute(\"style\");\r\n\r\n                            if (front) {\r\n                                if (front.replace(/\\s/g, \"\").includes(\"display:none\"))\r\n                                    this.style.display = \"\";\r\n                            }\r\n\r\n                            if (getComputedStyle(this).display === \"none\")\r\n                                this.style.display = \"initial\";\r\n                        });\r\n                    }\r\n\r\n                    Hide() {\r\n                        return this.Each(function () {\r\n                            this.style.display = \"none\";\r\n                        });\r\n                    }\r\n\r\n                    Opacity(value) {\r\n                        if (value)\r\n                            return this.Each(function () {\r\n                                this.style.opacity = value;\r\n                            });\r\n                        return this.el[0].style.opacity;\r\n                    }\r\n\r\n                    Classes(className) {\r\n                        let result = {},\r\n                            handler = (action) => {\r\n                                for (const e of this.el) e.classList[action](className);\r\n                            },\r\n                            list = [\"add\", \"remove\", \"toggle\"];\r\n\r\n                        result.list = [];\r\n\r\n                        for (const element of this.el[0].classList)\r\n                            result.list.push(element);\r\n\r\n                        result.contains = () => this.el[0].classList.contains(className);\r\n\r\n                        for (let a of list)\r\n                            result[a] = () => {\r\n                                handler(a);\r\n                                return this;\r\n                            };\r\n\r\n                        return result;\r\n                    }\r\n\r\n                    Css(declarations) {\r\n                        let actions = {};\r\n\r\n                        actions.set = (val) => {\r\n                            if (typeof declarations === \"object\") {\r\n                                let keys = Object.keys(declarations),\r\n                                    arr = {},\r\n                                    newCss = {},\r\n                                    max = {},\r\n                                    ancient = {},\r\n                                    origin = {};\r\n\r\n                                for (const element of keys) {\r\n                                    let forbidden =\r\n                                        \"duration property direction loop time delay text effect\";\r\n\r\n                                    if (\r\n                                        typeof declarations[element] !== \"object\" &&\r\n                                        !forbidden.includes(element)\r\n                                    ) {\r\n                                        declarations[element] = {\r\n                                            value: declarations[element]\r\n                                        };\r\n                                    }\r\n\r\n                                    let delay = declarations[element].delay,\r\n                                        duration =\r\n                                            declarations[element].duration ||\r\n                                            declarations.duration ||\r\n                                            0;\r\n                                    if (!declarations[element].delay) delay = 0;\r\n\r\n                                    if (!forbidden.includes(element)) {\r\n                                        let style = getComputedStyle(this.el[0]);\r\n                                        arr[element] = duration + \"ms \" + delay + \"ms\";\r\n                                        newCss[element] = declarations[element].value || 0;\r\n                                        if (ancient === origin)\r\n                                            ancient[element] = style[element] || 0;\r\n                                        max[element] = parseFloat(delay) + parseFloat(duration);\r\n                                    }\r\n                                }\r\n\r\n                                newCss.transition = el\r\n                                    .objectToStyle(arr)\r\n                                    .replace(/:/g, \" \")\r\n                                    .replace(/;/g, \", \");\r\n                                newCss[\"transition-timing-function\"] =\r\n                                    declarations.effect || \"ease\";\r\n                                if (declarations.particularly)\r\n                                    newCss[\"transition-property\"] =\r\n                                        declarations.particularly.value;\r\n\r\n                                if (!declarations.loop && !declarations.direction) {\r\n                                    if (declarations.duration)\r\n                                        newCss[\"transition-duration\"] =\r\n                                            declarations.duration + \"ms\";\r\n                                    if (declarations.delay)\r\n                                        newCss[\"transition-delay\"] = declarations.delay + \"ms\";\r\n                                }\r\n\r\n                                ancient.transition = newCss.transition;\r\n                                ancient[\"transition-timing-function\"] =\r\n                                    newCss[\"transition-timing-function\"];\r\n                                if (declarations.property)\r\n                                    ancient[\"transition-property\"] =\r\n                                        newCss[\"transition-property\"];\r\n                                if (declarations.duration)\r\n                                    ancient[\"transition-duration\"] =\r\n                                        newCss[\"transition-duration\"];\r\n                                if (declarations.delay)\r\n                                    ancient[\"transition-delay\"] = newCss[\"transition-delay\"];\r\n\r\n                                if (ancient === origin) {\r\n                                    origin = ancient;\r\n                                }\r\n\r\n                                let array = Object.values(max);\r\n                                max = Math.max(...array);\r\n                                return this.Each(function () {\r\n                                    let element = this,\r\n                                        times = 1,\r\n                                        boucle,\r\n                                        delay = 100;\r\n                                    if (declarations.loop || declarations.direction)\r\n                                        if (declarations.delay) delay = declarations.delay;\r\n                                    let interval = parseInt(max + delay) * 2 + 100;\r\n\r\n                                    if (declarations.direction || declarations.loop) {\r\n                                        action(max + delay);\r\n                                        boucle = setInterval(function () {\r\n                                            if (declarations.time)\r\n                                                action(max + delay, declarations.time);\r\n                                            else action(max + delay);\r\n                                        }, interval);\r\n                                        declarations.direction && clearInterval(boucle);\r\n                                    } else element.setAttribute(\"style\", el.objectToStyle(newCss));\r\n\r\n                                    function action(delay, time) {\r\n                                        element.setAttribute(\"style\", el.objectToStyle(newCss));\r\n                                        setTimeout(\r\n                                            () =>\r\n                                                element.setAttribute(\r\n                                                    \"style\",\r\n                                                    el.objectToStyle(ancient)\r\n                                                ),\r\n                                            parseInt(delay)\r\n                                        );\r\n\r\n                                        if (time) {\r\n                                            times++;\r\n                                            if (time <= times) clearInterval(boucle);\r\n                                        }\r\n                                    }\r\n                                });\r\n                            }\r\n\r\n                            return this.Each(function () {\r\n                                this.style[declarations] = val;\r\n                            });\r\n                        };\r\n\r\n                        actions.get = () => getComputedStyle(this.el[0])[declarations];\r\n\r\n                        return actions;\r\n                    }\r\n\r\n                    Style(options) {\r\n                        return this.Each(function () {\r\n                            this.animate(options, {\r\n                                duration: 0,\r\n                                fill: \"forwards\"\r\n                            });\r\n                        });\r\n                    }\r\n\r\n                    Anime(options) {\r\n                        let an = {};\r\n                        this.Each(function () {\r\n                            an.animation = this.animate(options.keyframes, {\r\n                                delay: options.delay || 0,\r\n                                duration: options.duration || 700,\r\n                                fill: options.fill || \"forwards\",\r\n                                easing: options.effect || \"ease-in-out\",\r\n                                times: options.iterations || 1\r\n                            });\r\n                        });\r\n\r\n                        an.start = () => {\r\n                            an.animation.play();\r\n                            return this;\r\n                        };\r\n\r\n                        an.freeze = () => {\r\n                            an.animation.pause();\r\n                            return this;\r\n                        };\r\n\r\n                        an.stop = () => {\r\n                            an.animation.finish();\r\n                            return this;\r\n                        };\r\n\r\n                        an.cancel = () => {\r\n                            an.animation.cancel();\r\n                            return this;\r\n                        };\r\n\r\n                        an.animation.addEventListener(\r\n                            \"finish\",\r\n                            () => options.onfinish && options.onfinish(this, an)\r\n                        );\r\n                        an.animation.addEventListener(\r\n                            \"cancel\",\r\n                            () => options.oncancel && options.oncancel(this, an)\r\n                        );\r\n                        return an;\r\n                    }\r\n\r\n                    Width(value) {\r\n                        if (value)\r\n                            return this.Each(function () {\r\n                                this.style.width = value;\r\n                            });\r\n                        return getComputedStyle(this.el[0]).width;\r\n                    }\r\n\r\n                    Height(value) {\r\n                        if (value)\r\n                            return this.Each(function () {\r\n                                this.style.height = value;\r\n                            });\r\n                        return getComputedStyle(this.el[0]).height;\r\n                    }\r\n\r\n                    Attr(attribute) {\r\n                        let options = {};\r\n\r\n                        options.set = (value) => {\r\n                            for (const el of this.el) el.setAttribute(attribute, value);\r\n\r\n                            return this;\r\n                        };\r\n\r\n                        options.remove = () => {\r\n                            for (const el of this.el) el.removeAttribute(attribute);\r\n\r\n                            return this;\r\n                        };\r\n\r\n                        options.get = () => this.el[0].getAttribute(attribute);\r\n\r\n                        options.has = () => this.el[0].hasAttribute(attribute);\r\n\r\n                        return options;\r\n                    }\r\n\r\n                    Text(str) {\r\n                        return el.CONTENT(\"Text\", str, this);\r\n                    }\r\n\r\n                    Html(html) {\r\n                        return el.CONTENT(\"HTML\", html, this);\r\n                    }\r\n\r\n                    Val(value) {\r\n                        let options = {};\r\n\r\n                        options.set = () => {\r\n                            for (const e of this.el) e.value = value;\r\n\r\n                            return this;\r\n                        };\r\n\r\n                        options.get = () => this.el[0].value;\r\n\r\n                        return options;\r\n                    }\r\n\r\n                    ScrollPosition(axe) {\r\n                        if (axe) return this.el[0].pageXOffset || this.el[0].scrollLeft;\r\n                        return this.el[0].pageYOffset || this.el[0].scrollTop;\r\n                    }\r\n\r\n                    Scroll() {\r\n                        const scrollToItemId = (containerId, srollToId) => {\r\n                            const scrollContainer = containerId;\r\n                            const item = srollToId;\r\n                            const from = scrollContainer.scrollTop;\r\n                            let by = item.offsetTop - scrollContainer.scrollTop;\r\n\r\n                            if (from < item.offsetTop) {\r\n                                if (\r\n                                    item.offsetTop >\r\n                                    scrollContainer.scrollHeight - scrollContainer.clientHeight\r\n                                ) {\r\n                                    by =\r\n                                        scrollContainer.scrollHeight -\r\n                                        scrollContainer.clientHeight -\r\n                                        scrollContainer.scrollTop;\r\n                                }\r\n                            }\r\n\r\n                            let currentIteration = 0;\r\n                            const animIterations = Math.round(60 * 0.5);\r\n\r\n                            (function scroll() {\r\n                                scrollContainer.scrollTop = easeOutCubic(\r\n                                    currentIteration,\r\n                                    from,\r\n                                    by,\r\n                                    animIterations\r\n                                );\r\n                                currentIteration++;\r\n\r\n                                if (currentIteration < animIterations) {\r\n                                    requestAnimationFrame(scroll);\r\n                                }\r\n                            })();\r\n                        };\r\n\r\n                        const easeOutCubic = (\r\n                            currentIteration,\r\n                            startValue,\r\n                            changeInValue,\r\n                            totalIterations\r\n                        ) => {\r\n                            return (\r\n                                changeInValue *\r\n                                (Math.pow(currentIteration / totalIterations - 1, 3) + 1) +\r\n                                startValue\r\n                            );\r\n                        };\r\n\r\n                        if (getComputedStyle(this.el[0].parentElement).position === \"fixed\")\r\n                            scrollToItemId(this.el[0].parentNode, this.el[0]);\r\n                        else {\r\n                            const c = firstEl.context.documentElement || firstEl.context.body;\r\n                            scrollToItemId(c, this.el[0]);\r\n                        }\r\n                        return this;\r\n                    }\r\n\r\n                    static CONTENT(fun, content, element) {\r\n                        let options = {};\r\n\r\n                        options.get = () => element.el[0][\"inner\" + fun];\r\n\r\n                        options.set = () => {\r\n                            for (let el of element.el) el[\"inner\" + fun] = content;\r\n\r\n                            return element;\r\n                        };\r\n\r\n                        options.clear = () => {\r\n                            for (let el of element.el) el[\"inner\" + fun] = \"\";\r\n\r\n                            return element;\r\n                        };\r\n\r\n                        options.append = (position) => {\r\n                            let pos = position || \"beforeend\";\r\n\r\n                            for (let el of element.el)\r\n                                el[\"insertAdjacent\" + fun](pos, content);\r\n\r\n                            return element;\r\n                        };\r\n\r\n                        return options;\r\n                    }\r\n\r\n                    static objectToStyle(cssProperties) {\r\n                        let s = Object.keys(cssProperties)\r\n                            .map((key) => key + \": \" + cssProperties[key])\r\n                            .join(\";\");\r\n                        return (\"'\" + s + \"'\").slice(1).slice(0, -1);\r\n                    }\r\n                }\r\n\r\n                return new el(selector);\r\n            };\r\n\r\n        this.Render = (old) => {\r\n            let keys = Object.keys(this.data),\r\n                content = old || this.child.innerHTML;\r\n\r\n            for (let item of keys) {\r\n                while (content.includes(\"{{\" + item + \"}}\"))\r\n                    content = content.replace(\r\n                        \"{{\" + item + \"}}\",\r\n                        this.data[item].replace(/<[^>]*>/g, \"\")\r\n                    );\r\n            }\r\n\r\n            this.child.innerHTML = content;\r\n        };\r\n\r\n        Shadow();\r\n\r\n        this.Component = (name, options) => {\r\n            let el = Find(name),\r\n                find = (s) => Find(s);\r\n\r\n            if (options.data)\r\n                if (!options.data.length) {\r\n                    options.obj = [];\r\n                    options.obj.push(options.data);\r\n                    options.data = options.obj;\r\n                }\r\n            if (typeof options.style === \"string\")\r\n                if (options.style.toLowerCase() === \"parent\")\r\n                    options.style = [app.style];\r\n            Seule.PDO(options.data || [{}], {\r\n                find: (s) => find(s),\r\n                element: el,\r\n                component: true,\r\n                mode: options.mode,\r\n                style: options.style || \"\",\r\n                execute: options.execute || false,\r\n                child: options.child || false,\r\n                columns: options.columns || false,\r\n                nest: options.nest || false,\r\n                item: options.item || false,\r\n                action: options.action || false,\r\n                selector: name,\r\n\r\n                query(item) {\r\n                    if (options.query) return options.query(item);\r\n                    return item;\r\n                },\r\n\r\n                template(item) {\r\n                    return options.template(item) || \"\";\r\n                },\r\n                handler(el) {\r\n                    options.handler && options.handler(el);\r\n                },\r\n                callback(el) {\r\n                    options.callback && options.callback(el);\r\n                }\r\n            });\r\n            return this;\r\n        };\r\n\r\n        app.root && this.Root();\r\n        this.Render();\r\n        app.handler &&\r\n        app.handler(\r\n            this,\r\n            (s) => Find(s),\r\n            (s) => Find(s, true)\r\n        );\r\n\r\n        this.Init = () => {\r\n            this.Render(old);\r\n            app.handler &&\r\n            app.handler(\r\n                this,\r\n                (s) => Find(s),\r\n                (s) => Find(s, true)\r\n            );\r\n        };\r\n    }\r\n\r\n    Root() {\r\n        const parameters = new URL(window.location).searchParams.entries();\r\n\r\n        for (let element of parameters) {\r\n            this.data[element[0]] = String(element[1]);\r\n        }\r\n\r\n        this.Render();\r\n        return this;\r\n    }\r\n\r\n    async Get(url, options) {\r\n        if (!options) options = {};\r\n        let parent = this.child,\r\n            formData = new FormData();\r\n        options.param = {\r\n            method: options.method || \"get\"\r\n        };\r\n\r\n        if (options.form) {\r\n            let newForm =\r\n                parent.querySelector(options.form) ||\r\n                this.RootElement.querySelector(options.form);\r\n            formData = new FormData(newForm);\r\n\r\n            newForm.onsubmit = async (e) => e.preventDefault();\r\n        }\r\n\r\n        if (options.file) {\r\n            if (typeof options.file === \"object\") {\r\n                for (const item of options.file) {\r\n                    let file;\r\n                    if (typeof item === \"object\") file = item;\r\n                    else file = parent.querySelector(item);\r\n                    formData.append(file.name, file.files[0]);\r\n                }\r\n            } else {\r\n                options.file = parent.querySelector(options.file);\r\n                formData.append(options.file.name, options.file.files[0]);\r\n            }\r\n        }\r\n\r\n        options.data &&\r\n        Object.keys(options.data).forEach((k) =>\r\n            formData.append(k, options.data[k])\r\n        );\r\n        if (options.method === \"post\") options.param.body = formData;\r\n        let response = await fetch(url, options.param);\r\n\r\n        if (response.ok) {\r\n            if (options.blob) return await response.blob();\r\n            if (options.json) return await response.json();\r\n            return await response.text();\r\n        } else return \"HTTP-Error: \" + response.status;\r\n    }\r\n\r\n    async Post(url, options) {\r\n        options.method = \"post\";\r\n        return await this.Get(url, options);\r\n    }\r\n\r\n    static Store(name) {\r\n        let options = {};\r\n\r\n        options.set = (data) => {\r\n            window.localStorage.setItem(name, JSON.stringify(data));\r\n            return this;\r\n        };\r\n\r\n        options.get = () => JSON.parse(window.localStorage.getItem(name));\r\n\r\n        options.remove = () => {\r\n            window.localStorage.removeItem(name);\r\n            return this;\r\n        };\r\n\r\n        options.reset = () => {\r\n            window.localStorage.clear();\r\n            return this;\r\n        };\r\n\r\n        return options;\r\n    }\r\n\r\n    static Audio(src) {\r\n        let audio = {};\r\n        audio.Delay = 0;\r\n        audio.Element = new Audio(src);\r\n        audio.Src = src;\r\n\r\n        audio.Play = function (delay) {\r\n            audio.Delay = delay * 1000;\r\n            setTimeout(function () {\r\n                audio.Element.pause();\r\n                audio.Element.play();\r\n            }, audio.Delay);\r\n            return this;\r\n        };\r\n\r\n        audio.Stop = function (timeOut) {\r\n            setTimeout(function () {\r\n                audio.Element.pause();\r\n                audio.Element.currentTime = 0;\r\n            }, timeOut * 1000);\r\n            return this;\r\n        };\r\n\r\n        audio.Pause = function (timeOut) {\r\n            setTimeout(function () {\r\n                audio.Element.pause();\r\n            }, timeOut * 1000);\r\n            return this;\r\n        };\r\n\r\n        return audio;\r\n    }\r\n\r\n    static Date(date) {\r\n        let dt = {};\r\n\r\n        dt.Increase = function (prefix, step) {\r\n            let tomorrow = new Date(date),\r\n                newDate = new Date(\r\n                    tomorrow.setMonth(tomorrow.getMonth() + parseInt(step))\r\n                ),\r\n                dateMonth = newDate.getMonth() + 1;\r\n\r\n            if (prefix) {\r\n                if (prefix.toLowerCase() === \"day\") {\r\n                    let tomorrow = new Date(date);\r\n                    tomorrow.setDate(tomorrow.getDate() + parseInt(step));\r\n                    dt.current =\r\n                        tomorrow.getFullYear() +\r\n                        \"-\" +\r\n                        (\"0\" + (tomorrow.getMonth() + 1)).slice(-2) +\r\n                        \"-\" +\r\n                        (\"0\" + tomorrow.getDate()).slice(-2);\r\n                } else {\r\n                    dateMonth = tomorrow.getFullYear() + 1;\r\n                    dt.current =\r\n                        dateMonth +\r\n                        \"-\" +\r\n                        (\"0\" + tomorrow.getMonth()).slice(-2) +\r\n                        \"-\" +\r\n                        (\"0\" + tomorrow.getDate()).slice(-2);\r\n                }\r\n            } else {\r\n                dt.current =\r\n                    newDate.getFullYear() +\r\n                    \"-\" +\r\n                    (\"0\" + dateMonth).slice(-2) +\r\n                    \"-\" +\r\n                    (\"0\" + newDate.getDate()).slice(-2);\r\n            }\r\n\r\n            dt.res = dt.current;\r\n            return this;\r\n        };\r\n\r\n        dt.BetWeen = function (options) {\r\n            let nwd = dt.current || dt.Increase(\"day\", 0).current,\r\n                d1 = options.from.split(options.character || \"-\"),\r\n                d2 = options.to.split(options.character || \"-\"),\r\n                c = nwd.split(options.character || \"-\");\r\n            options.from = new Date(d1[0], parseInt(d1[1]) - 1, d1[2]);\r\n            options.to = new Date(d2[0], parseInt(d2[1]) - 1, d2[2]);\r\n            nwd = new Date(c[0], parseInt(c[1]) - 1, c[2]);\r\n\r\n            if (nwd > options.from && nwd < options.to) {\r\n                if (options.handler) options.handler();\r\n                dt.res = true;\r\n                return this;\r\n            }\r\n\r\n            if (options.callback) options.callback();\r\n            dt.res = false;\r\n            return this;\r\n        };\r\n\r\n        dt.Ar = () => {\r\n            let newDate = new Date(date),\r\n                months = [\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\"\r\n                ],\r\n                days = [\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\",\r\n                    \"\"\r\n                ];\r\n            return (\r\n                days[newDate.getDay()] +\r\n                \" \" +\r\n                newDate.getDate() +\r\n                \" \" +\r\n                months[newDate.getMonth()] +\r\n                \" \" +\r\n                newDate.getFullYear()\r\n            );\r\n        };\r\n\r\n        return dt;\r\n    }\r\n\r\n    static Scroll(context = document) {\r\n        let sc = {}\r\n\r\n        sc.top = () => {\r\n            const c = context.documentElement.scrollTop || context.body.scrollTop;\r\n\r\n            if (c > 0) {\r\n                window.requestAnimationFrame(sc.top);\r\n                window.scrollTo(0, c - c / 8);\r\n            }\r\n\r\n            return this;\r\n        };\r\n\r\n        sc.bottom = () => {\r\n            const c = context.documentElement.scrollTop || context.body.scrollTop,\r\n                h = context.body.scrollHeight;\r\n\r\n            if (window.innerHeight + window.scrollY >= context.body.offsetHeight) {\r\n                window.scrollTo(0, c + h / 40);\r\n                return;\r\n            }\r\n\r\n            window.requestAnimationFrame(sc.bottom);\r\n            window.scrollTo(0, c + h / 40);\r\n            return this;\r\n        };\r\n\r\n        sc.onBottom = (handler, before = 0) => {\r\n            window.onscroll = (ev) => {\r\n                if (\r\n                    window.innerHeight + window.scrollY >=\r\n                    context.body.offsetHeight - before\r\n                )\r\n                    handler(this);\r\n            };\r\n\r\n            return this;\r\n        };\r\n\r\n        sc.onTop = (handler) => {\r\n            window.onscroll = (ev) => {\r\n                if (window.scrollY <= 0) handler(this);\r\n            };\r\n\r\n            return this;\r\n        };\r\n\r\n        sc.position = () => window.screenTop;\r\n\r\n        return sc;\r\n    }\r\n\r\n    static Orientation() {\r\n        if (screen.orientation.angle === 90) return \"Horizontally\";\r\n        return \"Vertically\";\r\n    }\r\n\r\n    static Screen(query, options) {\r\n        if (!query.includes(\"(\")) query = \"(\" + query + \")\";\r\n\r\n        let x = window.matchMedia(query),\r\n            myFunction = (x) => {\r\n                if (x.matches) options.handler && options.handler();\r\n                else options.callback && options.callback();\r\n                return x;\r\n            },\r\n            resultMatch = myFunction(x); // Call listener function at run time\r\n\r\n        x.addEventListener(\"change\", myFunction); // Attach listener function on state changes\r\n\r\n        return resultMatch;\r\n    }\r\n\r\n    static Print(options, context = document) {\r\n        let title = options.title || \"\",\r\n            body = context.querySelector(\"body\");\r\n        body.insertAdjacentHTML(\r\n            \"beforeend\",\r\n            '<iframe class=\"seule--frame\" name=\"sframe\" style=\"position: fixed; bottom: -100%\"></iframe>'\r\n        );\r\n        let iframeEl = context.getElementsByClassName(\"seule--frame\")[0];\r\n        let frameDoc = iframeEl.contentWindow\r\n            ? iframeEl.contentWindow\r\n            : iframeEl.contentDocument.document\r\n                ? iframeEl.contentDocument.document\r\n                : iframeEl.contentDocument;\r\n        frameDoc.document.open();\r\n        frameDoc.document.write(\"<html><head><title>\" + title + \"</title>\");\r\n        frameDoc.document.write(\"</head><body>\");\r\n        options.style &&\r\n        frameDoc.document.write(\r\n            '<link href=\"' +\r\n            options.style +\r\n            '\" rel=\"stylesheet\" type=\"text/css\" />'\r\n        );\r\n        frameDoc.document.write(options.template);\r\n        frameDoc.document.write(\"</body></html>\");\r\n        frameDoc.document.close();\r\n        setTimeout(function () {\r\n            window.frames[\"sframe\"].focus();\r\n            window.frames[\"sframe\"].print();\r\n        }, 500);\r\n    }\r\n\r\n    SceneHandler(options) {\r\n        let parent = this.child;\r\n        window.addEventListener(\r\n            \"scroll\",\r\n            function () {\r\n                elementFromTop(options);\r\n            },\r\n            false\r\n        );\r\n\r\n        function elementFromTop(options) {\r\n            let elem;\r\n\r\n            try {\r\n                elem = parent.querySelector(options.selector);\r\n            } catch (e) {\r\n                elem = options.selector;\r\n            }\r\n\r\n            let unit = options.unit || \"percent\",\r\n                distanceFromTop = options.distance,\r\n                winY = window.innerHeight || this.RootElement.documentElement.clientHeight,\r\n                distTop = elem.getBoundingClientRect().top,\r\n                distPercent = Math.round((distTop / winY) * 100),\r\n                distPixels = Math.round(distTop),\r\n                distUnit;\r\n            distUnit = unit === \"percent\" ? distPercent : distPixels;\r\n            if (distUnit <= distanceFromTop) options.handler();\r\n            else if (options.callback) options.callback();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    Scene(options) {\r\n        let i = 0;\r\n        this.SceneHandler({\r\n            selector: options.selector,\r\n            distance: options.distance || 0,\r\n            unit: options.unit || \"percent\",\r\n            handler: () => {\r\n                if (i === 0) {\r\n                    options.handler();\r\n                    i = 1;\r\n                }\r\n            },\r\n            callback: () => {\r\n                if (i === 1) {\r\n                    if (options.callback) {\r\n                        options.callback();\r\n                        i = 0;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n\r\n    static PDO(data, options, context = document) {\r\n        if (options)\r\n            if (!options.query) options.query = (item) => item;\r\n\r\n\r\n        let obj = [...data],\r\n            child = [],\r\n            nest = [],\r\n            result = {},\r\n            select = () => {\r\n                if (options) {\r\n                    let filter = obj.filter((el, index) => {\r\n                        if (options.execute !== \"remove duplicates\" && !options.columns)\r\n                            el.index = index;\r\n                        if (\r\n                            (options.child && options.execute !== \"insert\") ||\r\n                            (options.execute === \"insert\" && options.nest)\r\n                        )\r\n                            return el[options.child].some((e, i) => options.query(e, i));\r\n                        return options.query(el, index);\r\n                    });\r\n\r\n                    if (options.child) {\r\n                        for (const el of obj) {\r\n                            for (const e of el[options.child]) {\r\n                                if (options.execute !== \"remove duplicates\")\r\n                                    e.parent = el.index;\r\n                                child.push(e);\r\n                            }\r\n                        }\r\n\r\n                        nest = child;\r\n                        child = child.filter((el, index) => options.query(el, index));\r\n                    }\r\n\r\n                    return filter;\r\n                }\r\n            };\r\n\r\n        result.alter = (action, column, obj) => {\r\n            obj = obj || data;\r\n            obj.map(function (o) {\r\n                let c = o;\r\n\r\n                if (typeof column === \"object\" && action.toLowerCase() === \"replace\") {\r\n                    c[column[1]] = c[column[0]];\r\n                    delete c[column[0]];\r\n                }\r\n\r\n                if (action.toLowerCase() === \"drop\")\r\n                    for (const element of column) delete c[element];\r\n                if (action.toLowerCase() === \"add\")\r\n                    for (const element of column)\r\n                        if (!c.hasOwnProperty(element)) c[element] = \"\";\r\n                return c;\r\n            });\r\n            return result;\r\n        };\r\n\r\n        result.group = (column, obj) => {\r\n            obj = obj || data;\r\n            let da = [];\r\n            let group = [...new Set(obj.reduce((r, a) => r.concat(a[column]), []))];\r\n\r\n            for (const g of group) {\r\n                let e = '{\"' + column + '\":\"' + g + '\"}';\r\n                da.push(JSON.parse(e));\r\n            }\r\n\r\n            result.res = da;\r\n            return result;\r\n        };\r\n\r\n        result.removeDpl = (column, obj) => {\r\n            obj = obj || data;\r\n\r\n            for (let ob of obj) delete ob.index;\r\n\r\n            if (column) {\r\n                let lookup = new Set();\r\n                return obj.filter(\r\n                    (data) => !lookup.has(data[column]) && lookup.add(data[column])\r\n                );\r\n            }\r\n\r\n            let uniqueSet = new Set(obj.map(JSON.stringify));\r\n            result.res = Array.from(uniqueSet).map(JSON.parse);\r\n            return result;\r\n        };\r\n\r\n        result.sum = (obj) => {\r\n            obj = obj || data;\r\n            result.res = obj.reduce(\r\n                (sums, obj) =>\r\n                    Object.keys(obj).reduce((s, k) => {\r\n                        s[k] = (s[k] || 0) + +obj[k];\r\n                        return s;\r\n                    }, sums),\r\n                {}\r\n            );\r\n            return result;\r\n        };\r\n\r\n        result.sort = (column, obj) => {\r\n            let sortBy = () => (a, b) => {\r\n                if (a[column] > b[column]) return 1;\r\n                else if (a[column] < b[column]) return -1;\r\n                return 0;\r\n            };\r\n\r\n            obj = obj || data;\r\n            result.res = obj.sort(sortBy(column));\r\n            return result;\r\n        };\r\n\r\n        result.res = select();\r\n        result.child = child;\r\n\r\n        if (options) {\r\n            switch (options.execute) {\r\n                case \"update\":\r\n                    let items = Object.keys(options.item) || {};\r\n                    result.res.forEach((f) =>\r\n                        data.findIndex((e) => {\r\n                            if (e === f)\r\n                                for (const element of items) {\r\n                                    if (options.nest)\r\n                                        for (const i of result.child)\r\n                                            i[element] = options.item[element];\r\n                                    else e[element] = options.item[element];\r\n                                }\r\n                        })\r\n                    );\r\n                    break;\r\n\r\n                case \"delete\":\r\n                    result.child.forEach((f) =>\r\n                        nest.splice(\r\n                            nest.findIndex((e) => e === f),\r\n                            1\r\n                        )\r\n                    );\r\n\r\n                    if (options.nest) {\r\n                        result.res.forEach((f) =>\r\n                            f[options.child].findIndex((e) => {\r\n                                for (const element of result.child)\r\n                                    if (e === element)\r\n                                        f[options.child].splice(\r\n                                            f[options.child].findIndex((e) => e === element),\r\n                                            1\r\n                                        );\r\n                            })\r\n                        );\r\n                        result.res = data;\r\n                        break;\r\n                    }\r\n\r\n                    result.res.forEach((f) =>\r\n                        data.splice(\r\n                            data.findIndex((e) => e === f),\r\n                            1\r\n                        )\r\n                    );\r\n                    break;\r\n\r\n                case \"insert\":\r\n                    if (options.child)\r\n                        for (const element of result.res) {\r\n                            if (typeof element[options.child] !== \"object\")\r\n                                element[options.child] = [];\r\n                            options.item.parent = element.index;\r\n                            data[element.index][options.child].push(options.item);\r\n                            nest.push(options.item);\r\n                        }\r\n                    else data.push(options.item);\r\n                    break;\r\n            }\r\n\r\n            if (options.execute !== \"select\") {\r\n                result.res = data;\r\n                result.child = nest;\r\n            }\r\n\r\n            if (options.template) {\r\n                let obj = result.res,\r\n                    els = {};\r\n                if (!result.res) obj = result;\r\n                if (options.nest) obj = result.child;\r\n\r\n                if (options.component) {\r\n                    let sha = (done, shadow) => {\r\n                        done = done || obj;\r\n                        shadow.innerHTML = \"\";\r\n                        let parentElement = context.createElement(\"section\");\r\n                        parentElement.classList.add(\"s-parent\");\r\n\r\n                        selectStyle(options.style, shadow)\r\n\r\n                        for (const item of done) {\r\n                            let element = context.createElement(\"article\");\r\n                            element.classList.add(\"s-article\");\r\n                            element.innerHTML = options.template(item);\r\n                            parentElement.appendChild(element);\r\n                        }\r\n\r\n                        shadow.appendChild(parentElement);\r\n                        return shadow;\r\n                    };\r\n\r\n                    class common extends HTMLElement {\r\n                        constructor() {\r\n                            super();\r\n                            const shadow = this.attachShadow({\r\n                                mode: options.mode || \"open\"\r\n                            });\r\n                            sha(obj, shadow);\r\n\r\n                            if (options.mode !== \"closed\") {\r\n                                els = options.element;\r\n\r\n                                els.Select = (selector) =>\r\n                                    options.find(shadow.querySelectorAll(selector));\r\n                            }\r\n                            else\r\n                                els.Select = () =>\r\n                                    console.log(\r\n                                        \"mode is closed! to use Select method, Switch to the open Mode!\"\r\n                                    );\r\n\r\n                            els.Data = obj;\r\n                            els.Init = (data, handler)=> initial(data, handler);\r\n\r\n                            (obj.length && options.handler) ? options.handler(els): options.callback(options.find(shadow.querySelector('.s-parent')));\r\n\r\n                            function initial(done){\r\n                                sha(done, shadow);\r\n                                return options.handler(els)\r\n                            }\r\n\r\n                        }\r\n                    }\r\n\r\n                    try {customElements.define(options.selector, common)}\r\n                    catch (e) {/*console.log('Data has been Reset!')*/}\r\n                }\r\n                else {\r\n                    options.element.Html(\"\").set();\r\n                    for (const item of obj) {\r\n                        options.element.Html(options.template(item)).append();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        options.callback && options.callback(options.element, result);\r\n        return result;\r\n    }\r\n\r\n    static HtmlEscape(str) {\r\n        const tagsToReplace = {\r\n                \"&\": \"&amp;\",\r\n                \"<\": \"&lt;\",\r\n                \">\": \"&gt;\",\r\n                '\"': \"&#34;\",\r\n                \"'\": \"&#39;\",\r\n                \"`\": \"&#180;\"\r\n            },\r\n            replaceTag = (tag) => tagsToReplace[tag] || tag,\r\n            safe_tags_replace = (s) => s.replace(/[&<>\"']/g, replaceTag);\r\n\r\n        return safe_tags_replace(str);\r\n    }\r\n\r\n    static BytesToSize(bytes) {\r\n        const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\r\n        if (bytes.toString() === \"0\") return \"0 Byte\";\r\n        let i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));\r\n        return Math.round(bytes / Math.pow(1024, i), 2) + \" \" + sizes[i];\r\n    }\r\n}\r\n\r\nfunction selectElement(el, context = document) {\r\n    let element = {};\r\n\r\n    element.context = context;\r\n\r\n    try {\r\n        element.el = context.querySelector(el);\r\n        element.e = el.replace(\"#\", \"\")\r\n    } catch (e) {\r\n        element.el = el;\r\n        element.e = el.getAttribute(\"id\").replace(\"#\", \"\")\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\nfunction selectStyle(name, shadow, context=document){\r\n    if(name){\r\n        if(name.includes(\".css\")){\r\n            const l = context.createElement(\"link\");\r\n            l.setAttribute(\"rel\", \"stylesheet\");\r\n            l.setAttribute(\"href\", name);\r\n            shadow.appendChild(l);\r\n        }\r\n        else {\r\n            const links = context.querySelectorAll(\"head link\");\r\n            for (const link of links)\r\n                if(link.getAttribute(\"about\"))\r\n                    if (link.getAttribute(\"about\").includes(name)) {\r\n                        const l = context.createElement(\"link\");\r\n                        l.setAttribute(\"rel\", \"stylesheet\");\r\n                        l.setAttribute(\"href\", link.getAttribute(\"href\"));\r\n                        shadow.appendChild(l);\r\n                    }\r\n        }\r\n    }\r\n}\r\n\r\n(function(){\r\n    Element.prototype._addEventListener = Element.prototype.addEventListener;\r\n    Element.prototype._removeEventListener = Element.prototype.removeEventListener;\r\n    Element.prototype.addEventListener = function(type,listener,useCapture=false) {\r\n        this._addEventListener(type,listener,useCapture);\r\n        if(!this.eventListenerList) this.eventListenerList = {};\r\n        if(!this.eventListenerList[type]) this.eventListenerList[type] = [];\r\n        this.eventListenerList[type].push( {type, listener, useCapture} );\r\n    };\r\n    Element.prototype.removeEventListener = function(type,listener,useCapture=false) {\r\n        this._removeEventListener(type,listener,useCapture);\r\n        if(!this.eventListenerList) this.eventListenerList = {};\r\n        if(!this.eventListenerList[type]) this.eventListenerList[type] = [];\r\n        for(let i=0; i<this.eventListenerList[type].length; i++){\r\n            if( this.eventListenerList[type][i].listener===listener && this.eventListenerList[type][i].useCapture===useCapture){\r\n                this.eventListenerList[type].splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        if(this.eventListenerList[type].length===0) delete this.eventListenerList[type];\r\n    };\r\n    Element.prototype.getEventListeners = function(type){\r\n        if(!this.eventListenerList) this.eventListenerList = {};\r\n        if(type===undefined)  return this.eventListenerList;\r\n        return this.eventListenerList[type];\r\n    };\r\n}())\r\n\r\nmodule.exports.Seule = Seule;\r\n\n\n//# sourceURL=webpack://hello-npm/./node_modules/seule/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.html */ \"./src/index.html\");\n/* harmony import */ var seule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! seule */ \"./node_modules/seule/index.js\");\n\r\n\r\n//where you import your component\r\nconst app = new seule__WEBPACK_IMPORTED_MODULE_1__.Seule({\r\n    el: '#app',\r\n    style: 'app',\r\n    data: {\r\n        msg : \"Hello Seule\"\r\n    }\r\n})\r\n\n\n//# sourceURL=webpack://hello-npm/./src/index.js?");

/***/ }),

/***/ "./src/asset/img/background.png":
/*!**************************************!*\
  !*** ./src/asset/img/background.png ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"e057613db13b925ed876.png\";\n\n//# sourceURL=webpack://hello-npm/./src/asset/img/background.png?");

/***/ }),

/***/ "./src/css/app.css":
/*!*************************!*\
  !*** ./src/css/app.css ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"f8836130fa831e754ea6.css\";\n\n//# sourceURL=webpack://hello-npm/./src/css/app.css?");

/***/ }),

/***/ "./src/css/main.css":
/*!**************************!*\
  !*** ./src/css/main.css ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"d0cd540f72c319cb188d.css\";\n\n//# sourceURL=webpack://hello-npm/./src/css/main.css?");

/***/ }),

/***/ "./src/favicon.ico":
/*!*************************!*\
  !*** ./src/favicon.ico ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"f86cff5bb1065c21dd5b.ico\";\n\n//# sourceURL=webpack://hello-npm/./src/favicon.ico?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;